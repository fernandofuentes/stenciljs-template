import { registerInstance as __stencil_registerInstance } from "@stencil/core";
import { Host, h, Build } from "@stencil/core";
import siteStructure from '../../assets/docs-structure.json';
import { findItem, fileNotFound } from '../../global/site-structure-utils';
export const DocumentComponent = class {
    constructor(hostRef) {
        __stencil_registerInstance(this, hostRef);
    }
    async componentWillRender() {
        if (this.page) {
            console.log('componentWillRender', this.page);
            const data = this.data = findItem(siteStructure, this.page);
            if (!Build.isBrowser && !data.item) {
                fileNotFound();
                return;
            }
            if (data.item && data.item.filePath) {
                this.content = await fetchContent(data.item.filePath);
            }
        }
    }
    render() {
        const data = this.data;
        const content = this.content;
        if (!data || !content) {
            return null;
        }
        console.log('render3', this.page);
        return (h(Host, null, h("div", { class: "container" }, h("div", { class: "container-inner" }, h("stencil-route-title", { pageTitle: content.title }), h("app-burger", null), h("site-menu", { selectedParent: data.parent, siteStructureList: siteStructure }), h("div", { class: "doc-content measure-lg" }, toHypertext(content.hypertext), h("lower-content-nav", { next: data.nextItem, prev: data.prevItem }), h("contributor-list", { contributors: content.contributors })), h("in-page-navigation", { pageLinks: content.headings, srcUrl: content.srcPath, currentPageUrl: content.url })))));
    }
    static get style() { return "STYLE_TEXT_PLACEHOLDER:doc-component"; }
};
const localCache = new Map();
const fetchContent = (path) => {
    let promise = localCache.get(path);
    if (!promise) {
        console.log('fetchContent', path);
        promise = fetch(path).then(response => response.json());
        localCache.set(path, promise);
    }
    return promise;
};
const toHypertext = (data) => {
    if (!Array.isArray(data)) {
        console.error('content error, hypertext is undefined');
        return null;
    }
    const args = [];
    for (let i = 0; i < data.length; i++) {
        let arg = data[i];
        if (i === 0 && typeof arg === 'string' && tagBlacklist.includes(arg.toLowerCase().trim())) {
            arg = 'template';
        }
        else if (i === 1 && arg) {
            const attrs = {};
            Object.keys(arg).forEach(key => {
                const k = key.toLowerCase();
                if (!k.startsWith('on') && k !== 'innerhtml') {
                    attrs[key] = arg[key];
                }
            });
            arg = attrs;
        }
        else if (i > 1) {
            if (Array.isArray(arg)) {
                arg = toHypertext(arg);
            }
        }
        args.push(arg);
    }
    return h.apply(null, args);
};
const tagBlacklist = ['script', 'link', 'meta', 'object', 'head', 'html', 'body'];
